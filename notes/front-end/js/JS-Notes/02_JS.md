# Arrays <a name="Arrays"></a>
With JavaScript array variables, we can store several pieces of data in one place.

You start an array declaration with an opening square bracket, end it with a closing square bracket, and put a comma between each entry, like this:
```javascript
var sandwich = ["peanut butter", "jelly", "bread"]
```

## Multi-dimensional Array (Nesting) <a name=""></a>
You can also nest arrays within other arrays, like this: 
```javascript
var teams = [["Bulls", 23], ["White Sox", 45]]. 
```
This is also called a Multi-dimensional Array.

## Using Indexes <a name=""></a>
We can access the data inside arrays using indexes.Array indexes are written in the same bracket notation that strings use, except that instead of specifying a character, they are specifying an entry in the array. Like strings, arrays use zero-based indexing, so the first element in an array is element 0.

### Accessing Array Data <a name=""></a>
```javascript
var array = [1,2,3]; 
array[0];             // equals 1 
var data = array[1];  // equals 2
```

Note: There shouldn't be any spaces between the array name and the square brackets, like array [0]. Although JavaScript is able to process this correctly, this may confuse other programmers reading your code.

#### Accessing Multi-dimensional Array Data <a name=""></a>
One way to think of a multi-dimensional array, is as an array of arrays. 

When you use brackets to access your array, the first set of brackets refers to the entries in the outer-most (the first level) array, and each additional pair of brackets refers to the next level of entries inside.

### Modifying Array Data <a name=""></a>
Unlike strings, the entries of arrays are mutable and can be changed freely.
```javascript
var ourArray = [3,2,1];
		ourArray[0] = 1; // equals [1,2,1]
```
		
## Manipulating Arrays <a name=""></a>
### Append Data  <a name=""></a>
#### to Array End (.push) <a name=""></a>
An easy way to append data to the end of an array is via the push() function.

.push() takes one or more parameters and "pushes" them onto the end of the array. 
```javascript
var arr = [1,2,3]; arr.push(4); // arr is now [1,2,3,4]
```
#### to Array Front (.unshift) <a name=""></a>

### Remove Data
#### From Last Index (.pop) <a name=""></a>
pop() is used to "pop" a value off of the end of an array. We can store this "popped off" value by assigning it to a variable. 

In other words, .pop() removes the last element from an array and returns that element.
#### From First Index (.shift) <a name=""></a>

### Add/Remove Any Number of Consecutive Elements(.splice) <a name=""></a>
#### Remove <a name=""></a>
splice() can take up to 3 parameters, but for now, we'll focus on just the first 2.

The first two parameters of splice() are integers which represent indexes, or positions, of the array that splice() is being called upon. 

And remember, arrays are zero-indexed, so to indicate the first element of an array, we would use 0. splice()'s first parameter represents the index on the array from which to begin removing elements, while the second parameter indicates the number of elements to delete. For example:
```javascript
let array = ['today', 'was', 'not', 'so', 'great'];
array.splice(2, 2); 	// remove 2 elements beginning with the 3rd element // array now equals ['today', 'was', 'great']
```

splice() not only modifies the array it's being called on, but it also returns a new array containing the value of the removed elements:
```javascript
let array = ['I', 'am', 'feeling', 'really', 'happy'];
let newArray = array.splice(3, 2);	// newArray equals ['really', 'happy']
```
#### Add <a name=""></a>
In addition to splice removing elements, we can use that third parameter, which represents one or more elements, to add them as well. 
This can be incredibly useful for quickly switching out an element, or a set of elements, for another. 

For instance, let's say you're storing a color scheme for a set of DOM elements in an array, and want to dynamically change a color based on some action:

```javascript
 function colorChange(arr, index, newColor) {arr.splice(index, 1, newColor);return arr;}
let colorScheme = ['#878787', '#a08794', '#bb7e8c', '#c9b6be', '#d1becf'];
colorScheme = colorChange(colorScheme, 2, '#332327'); // we have removed '#bb7e8c' and added '#332327' in its place
// colorScheme now equals ['#878787', '#a08794', '#332327', '#c9b6be', '#d1becf']
```

This function takes an array of hex values, an index at which to remove an element, and the new color to replace the removed element with. 

The return value is an array containing a newly modified color scheme! While this example is a bit oversimplified, we can see the value that utilizing splice() to its maximum potential can have.

## Copying Arrays <a name=""></a>
### Copy an Array with slice() <a name=""></a>
slice(), rather than modifying an array, copies, or extracts, a given number of elements to a new array, leaving the array it is called upon untouched.

slice() takes only 2 parameters: 
the first is the index at which to begin extraction
the second is the index at which to stop extraction (extraction will occur up to, but not including the element at this index). Consider this:

```javascript
let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];
let todaysWeather = weatherConditions.slice(1, 3);
// todaysWeather equals ['snow', 'sleet'];
// weatherConditions still equals ['rain', 'snow', 'sleet', 'hail', 'clear']
```
In effect, we have created a new array by extracting elements from an existing array.

### Copy an Array with the Spread Operator <a name=""></a>
While slice() allows us to be selective about what elements of an array to copy, among several other useful tasks, ES6's new spread operator allows us to easily copy all of an array's elements, in order, with a simple and highly readable syntax. The spread syntax simply looks like this: ...

In practice, we can use the spread operator to copy an array like so:
```javascript
let thisArray = [true, true, undefined, false, null];
let thatArray = [...thisArray];
// thatArray equals [true, true, undefined, false, null]
// thisArray remains unchanged, and is identical to thatArray
```
## Combining Arrays <a name=""></a>
Another huge advantage of the spread operator, is the ability to combine arrays, or to insert all the elements of one array into another, at any index. 

With more traditional syntaxes, we can concatenate arrays, but this only allows us to combine arrays at the end of one, and at the start of another. Spread syntax makes the following operation extremely simple:
```javascript
let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];
let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];
// thatArray now equals ['basil', 'cilantro', 'sage', 'rosemary', 'parsley', 'thyme', 'coriander']
```
Using spread syntax, we have just achieved an operation that would have been more more complex and more verbose had we used traditional methods.

# Functions <a name=""></a>
In JavaScript, we can divide up our code into reusable parts called functions.Here's an example of a function:
```javascript    
function functionName() {
   console.log("Hello World");
}
```
You can call or invoke this function by using its name followed by parentheses, like this: functionName();

Each time the function is called it will print out the message "Hello World" on the dev console. All of the code between the curly braces will be executed every time the function is called.

## Parameters and Arguments <a name=""></a>
Parameters are variables that act as placeholders for the values that are to be input to a function when it is called. 

When a function is defined, it is typically defined along with one or more parameters. 
The actual values that are input (or "passed") into a function when it is called are known as arguments.

Here is a function with two parameters, param1 and param2: unction testFun(param1, param2) {console.log(param1, param2);}

Then we can call testFun: testFun("Hello", "World");

We have passed two arguments, "Hello" and "World". Inside the function, param1 will equal "Hello" and param2 will equal "World". 

Note: that you could call testFun again with different arguments and the parameters would take on the value of the new arguments.

## Global Scope <a name=""></a>
In JavaScript, scope refers to the visibility of variables. Variables which are defined outside of a function block have Global scope. 
This means, they can be seen everywhere in your JavaScript code.

Variables which are used without the var keyword are automatically created in the global scope. This can create unintended consequences elsewhere in your code or when running a function again. You should always declare your variables with var.

## Local Scope <a name=""></a>
Variables which are declared within a function, as well as the function parameters have local scope. 
That means, they are only visible within that function. Here is a function myTest with a local variable called loc.
```javascript
function myTest() {var loc = "foo"; console.log(loc);}
    	myTest(); // logs "foo"
    	console.log(loc); // loc is not defined
	//c is not defined outside of the function.
```
## Scope Precedence (Local Wins) <a name=""></a>
It is possible to have both local and global variables with the same name. When you do this, the local variable takes precedence over the global variable.In this example: 
```javascript
var someVar = "Hat";
function myFun() {var someVar = "Head";return someVar;} //The function myFun will return "Head" because the local version of the variable is present.
```
## Return Statement <a name=""></a>

We can pass values into a function with arguments. You can use a return statement to send a value back out of a function.

Remember everything to the right of the equal sign is resolved before the value is assigned. 
This means we can take the return value of a function and assign it to a variable.

Assume we have pre-defined a function sum which adds two numbers together, then: ourSum = sum(5, 12); will call sum function, which returns a value of 17 and assigns it to ourSum variable.

When a return statement is reached, the execution of the current function stops and control returns to the calling location.

# Conditional Logic <a name=""></a>
If statements are used to make decisions in code. The keyword if tells JavaScript to execute the code in the curly braces under certain conditions, defined in the parentheses. 

These conditions are known as Boolean conditions and they may only be true or false.
When the condition evaluates to true, the program executes the statement inside the curly braces. 
When the Boolean condition evaluates to false, the statement inside the curly braces will not execute.

Pseudocode: if (condition is true) {statement is executed}

Note: Order is important in if, else if statements. The loop is executed from top to bottom so you will want to be careful of what statement comes first.

## Comparison Operators <a name=""></a>
There are many Comparison Operators in JavaScript. All of these operators return a boolean true or false value:
```javascript
==, ===, !=, !==, >, >=, <, <=, &&, ||
```
## Switch Statements <a name=""></a>

## Conditional (Ternary) Operator <a name=""></a>
The conditional operator, also called the ternary operator, can be used as a one line if-else expression.The syntax is: 
```javascript
condition ? statement-if-true : statement-if-false;
```
### Chaining <a name=""></a>
You can also chain them together to check for multiple conditions.
```javascript
function findGreaterOrEqual(a, b) {
	return (a === b) ? "a and b are equal" : (a > b) ? "a is greater" : "b is greater";
}
```

# Objects <a name=""></a>
Objects are similar to arrays, except that instead of using indexes to access and modify their data, you access the data in objects through what are called properties.Here's a sample object: 
```javascript
var cat = {"name": "Whiskers", "legs": 4, "tails": 1, "enemies": ["Water", "Dogs"]};
```
Objects are useful for storing data in a structured way, and can represent real world objects, like a cat.

## Accessing Properties <a name=""></a>

### Dot Operator <a name=""></a>
The dot operator is what you use when you know the name of the property you're trying to access ahead of time.
Here is a sample of using the dot operator (.) to read an object property: cat.name // "Whiskers"

### Bracket Notation <a name=""></a>
If the property of the object you are trying to access has a space in it's name, you will need to use bracket notation.
Here is a sample of using bracket notation to read an object property: cat[name] // "Whiskers"
		
Note:that property names with spaces in them must be in quotes (single or double).

#### A Variable between the Brackets <a name=""></a>
Another use of bracket notation on objects is to use a variable to access a property. 
This can be very useful for iterating through lists of the object properties or for doing the lookup. Here is an example of using a variable to access a property:

```javascript
var someProp = "propName";
var myObj = {propName: "Some Value"}
myObj[someProp]; // "Some Value"
```
Note: that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name.

## Updating Properties <a name=""></a>
After you've created a JavaScript object, you can update its properties at any time just like you would update any other variable. 
You can use either dot or bracket notation to update. eg. cat.name = "Harry"  or cat[name] = "Harry"

## Adding Properties <a name=""></a>
You can add new properties to existing JavaScript objects the same way you would update them.

## Deleting Properties <a name=""></a>
We can also delete properties from objects like this: delete cat.name;

## Objects as Lookups <a name=""></a>
Objects can be thought of as a key/value storage, like a dictionary. 
If you have tabular data, you can use an object to "lookup" values rather than a switch statement or an if/else chain. 
This is most useful when you know that your input data is limited to a certain range.

## Testing for a Property <a name=""></a>
Sometimes it is useful to check if the property of a given object exists or not. 
We can use the .hasOwnProperty(propname) method of objects to determine if that object has the given property name. 
.hasOwnProperty() returns true or false if the property is found or not.

## Iterating Keys <a name=""></a>
Sometimes you may need to iterate through all the keys within an object. This requires a specific syntax in JavaScript called a for...in statement. For our users object, this could look like:
```javascript
for (let user in users) {console.log(user);}; // logs:Alan Jeff Sarah Ryan
```

In this statement, we defined a variable user, and as you can see, this variable was reset during each iteration to each of the object's keys as the statement looped through the object, resulting in each user's name being printed to the console.

NOTE:Objects do not maintain an ordering to stored keys like arrays do; thus a keys position on an object, or the relative order in which it appears, is irrelevant when referencing or accessing that key.

### Generate an Array of All Object Keys <a name=""></a>
We can also generate an array which contains all the keys stored in an object using the Object.keys() method and passing in an object as the argument. 

This will return an array with strings representing each property in the object. Again, there will be no specific order to the entries in the array.

# Looping <a name=""></a>
You can run the same code multiple times by using a loop.

## while <a name=""></a>
## for <a name=""></a>
