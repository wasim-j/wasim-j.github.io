# Variables

## The Problem with var
### Overwrite Variable Declarations
One of the biggest problems with declaring variables with the var keyword is that you can overwrite variable declarations without an error.

In a small application, you might not run into this type of problem, but when your code becomes larger, you might accidently overwrite a variable that you did not intend to overwrite. Because this behaviour does not throw an error, searching and fixing bugs becomes more difficult.

### Hoisting
Another problem with the var keyword is that it is hoisted to the top of your code when it compiles. This means that you can use a variable before you declare it.

## Solution = let
A new keyword called let was introduced in ES6 to solve the problems with the var keyword. With the let keyword, all the examples we just saw will cause an error to appear. 

We can no longer overwrite variables or use a variable before we declare it. 

Note: Some modern browsers require you to add "use strict"; to the top of your code before you can use the new features of ES6.

### Let provides Block Scope
When you declare a variable with the var keyword, it is declared globally, or locally if declared inside a function.

The let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.

## Read-Only Variables (const)
let is not the only new way to declare variables. In ES6, you can also declare variables using the const keyword.

const has all the awesome features that let has, with the added bonus that variables declared using const are read-only. 

They are a constant value, which means that once a variable is assigned with const, it cannot be reassigned. A common practice is to name your constants in all upper-cases and with an underscore to separate words (e.g. EXAMPLE_VARIABLE).

### Objects Declared with Constant are Still Mutable
The const declaration has many use-cases in modern JavaScript.

Some developers prefer to assign all their variables using const by default, unless they know they will need to reassign the value. 
Only in that case, they use let.

However, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of the variable identifier.

# Arrow Functions
In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. 

Instead, we create inline functions. We don't need to name these functions because we do not reuse them anywhere else.To achieve this, we often use the following syntax:

```javascript
const myFunc = function() {const myVar = "value"; return myVar;}
```

ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use arrow function syntax:
```javascript
const myFunc = () => {const myVar = "value";return myVar;}
```
    
When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword return as well as the brackets surrounding the code. This helps simplify smaller functions into one-line statements: 
```javascript
const myFunc= () => "value"  //This code will still return value by default.
```

## Parameters
Just like a normal function, you can pass arguments into arrow functions.
```javascript
const doubler = (item) => item * 2; // doubles input value and returns it
```
You can pass more than one argument into arrow functions as well.

## Higher Order Arrow Functions
Arrow functions work really well with higher order functions, such as map(), filter(), and reduce(), that take other functions as arguments for processing collections of data.

Read the following code:
```javascript
FBPosts.filter(function(post) { return post.thumbnail !== null && post.shares > 100 && post.likes > 500;})
```

We have written this with filter() to at least make it somewhat readable. Now compare it to the following code which uses arrow function syntax instead: 
```javascript
FBPosts.filter((post) => post.thumbnail !== null && post.shares > 100 && post.likes > 500)
```

This code is more succinct and accomplishes the same task with fewer lines of code.

# Default Parameters
In order to help us create more flexible functions, ES6 introduces default parameters for functions. Check out this code:

```javascript
function greeting(name = "Anonymous") {return "Hello " + name;}

console.log(greeting("John")); // Hello John
console.log(greeting());       // Hello Anonymous
```

The default parameter kicks in when the argument is not specified (it is undefined).

As you can see in the example above, the parameter name will receive its default value "Anonymous" when you do not provide a value for the parameter. You can add default values for as many parameters as you want.

# Rest Operator
In order to help us create more flexible functions, ES6 introduces the rest operator for function parameters. 

With the rest operator, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.

Check out this code:
```javascript
function howMany(...args) {return "You have passed " + args.length + " arguments.";}

console.log(howMany(0, 1, 2));                        // You have passed 3 arguments
console.log(howMany("string", null, [1, 2, 3], { })); // You have passed 4 arguments.
```
The rest operator eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.

# Spread Operator
ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.

The ES5 code below uses apply() to compute the maximum value in an array:
```javascript
var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr); // returns 89
```
We had to use Math.max.apply(null, arr) because Math.max(arr) returns NaN. Math.max() expects comma-separated arguments, but not an array.

The spread operator makes this syntax much better to read and maintain.
```javascript
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr); // returns 89
```
...arr returns an unpacked array. In other words, it spreads the array.

However, the spread operator only works in-place, like in an argument to a function or in an array literal. The following code will not work:
```javascript
const spreaded = ...arr; // will throw a syntax error
```

# Destructuring Asssignment
We earlier saw how spread operator can effectively spread, or unpack, the contents of the array. We can do something similar with objects as well.

## Assign Variables from Objects
Destructuring assignment is special syntax for neatly assigning values taken directly from an object to variables.

Consider the following ES5 code:
```javascript
var voxel = {x: 3.6, y: 7.4, z: 6.54 };
    		var x = voxel.x; // x = 3.6
    		var y = voxel.y; // y = 7.4
    		var z = voxel.z; // z = 6.54

```

Here's the same assignment statement with ES6 destructuring syntax:
```javascript
const { x, y, z } = voxel; // x = 3.6, y = 7.4, z = 6.54
```
    		
If instead you want to store the values of voxel.x into a, voxel.y into b, and voxel.z into c, you have that freedom as well.
```javascript
const { x : a, y : b, z : c } = voxel // a = 3.6, b = 7.4, c = 6.54
```
You may read it as "get the field x and copy the value into a," and so on.

## Assign Variables from Nested Objects
We can similarly destructure nested objects into variables.Consider the following code:
```javascript
const a = {
      start: { x: 5, y: 6},
      end: { x: 6, y: -9 }
};
const { start : { x: startX, y: startY }} = a;
console.log(startX, startY); // 5, 6
```

In the example above, the variable start is assigned the value of a.start, which is also an object.

## Assign Variables from Arrays
ES6 makes destructuring arrays as easy as destructuring objects.

One key difference between the spread operator and array destructuring is that the spread operator unpacks all contents of an array into a comma-separated list. 

Consequently, you cannot pick and choose which elements or you want to assign to variables.Destructuring an array lets us do exactly that:
```javascript
const [a, b] = [1, 2, 3, 4, 5, 6];
console.log(a, b); // 1, 2
```

The variable a is assigned the first value of the array, and b is assigned the second value of the array.

We can also access the value at any index in an array with destructuring by using commas to reach the desired index:
```javascript
const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c); // 1, 2, 5 
```
## Rest Operator to Reassign Array Elements
In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array.

The result is similar to Array.prototype.slice(), as shown below:
```javascript
const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b); // 1, 2
console.log(arr); // [3, 4, 5, 7]
```
Variables a and b take the first and second values from the array. After that, because of rest operator's presence, arr gets rest of the values in the form of an array.
The rest element only works correctly as the last variable in the list. As in, you cannot use the rest operator to catch a subarray that leaves out last element of the original array.

## Pass an Object as a Function's Parameters
In some cases, you can destructure the object in a function argument itself. Consider the code below:
```javascript
const profileUpdate = (profileData) => {
      const { name, age, nationality, location } = profileData;
      // do something with these variables
}
```
This effectively destructures the object sent into the function. This can also be done in-place:
```javascript
const profileUpdate = ({ name, age, nationality, location }) => {
      /* do something with these fields */
}
```
This removes some extra lines and makes our code look neat.
This has the added benefit of not having to manipulate an entire object in a function; only the fields that are needed are copied inside the function.

# String Interpolation

# Concise Declarations

## Object Literals
ES6 adds some nice support for removing boiler-plate from object literals declaration. Consider the following:
```javascript
const getMousePosition = (x, y) => {return {x: x, y: y}}
```
It's a simple function that returns an object, which has two fields.

ES6 provides a syntactic sugar to remove the redundancy from having to write x: x. 
You can simply write x once, and it would convert that to x : x (or some equivalent of it) under the hood. The code now becomes:
```javascript
const getMousePosition = (x, y) => ({x, y})
```

## Remove Function Keywoed in Object Literals
With ES6, it's possible to remove the keyword function as follows, from object literals:
```javascript
const Container extends Component {render: function() {return {Container}}}
```
We can remove the function keyword and colon (:) altogether - and get this:
```javascript
const Container extends Component {render() {return {Container}}}
```

# Class Syntax
ES6 provides a new syntax to help create objects, using the keyword class.
This is to be noted, that the class syntax is just a syntax, and not a full-fledged class based implementation of object oriented paradigm, unlike in languages like Java, or Python, or Ruby etc.

In ES5, we usually define a constructor function, and use the new keyword to instantiate an object.
```javascript
var SpaceShuttle = function(targetPlanet){
   this.targetPlanet = targetPlanet;
}
var zeus = new spaceShuttle('Jupiter');
```
The class syntax simply replaces the constructor function creation:
```javascript
class SpaceShuttle {
  constructor(targetPlanet){
    this.targetPlanet = targetPlanet;
  }
}
const zeus = new spaceShuttle('Jupiter');
```
Notice that the class keyword declares a new function, and a constructor was added, which would be invoked when new is called - to create a new object.

# Getters and Setters
You can obtain values from an object, and set a value of a property within an object.These are classically called getters and setters.

Getter functions are meant to simply return (get) the value of an object's private variable to the user without the user directly accessing the private variable.
Setter functions are meant to modify (set) the value of an object's private variable based on the value passed into the setter function. 
This change could involve calculations, or even overwriting the previous value completely.
```javascript
    class Book {
      constructor(author) {
        this._author = author;
      }
      // getter
      get writer(){
        return this._author;
      }
      // setter
      set writer(updatedAuthor){
        this._author = updatedAuthor;
      }
    }
    const lol = new Book('anonymous');
    console.log(lol.writer);
    lol.writer = 'wut';
    console.log(lol.writer);
```
Notice the syntax we are using to invoke the getter and setter - as if they are not even functions.
Getters and setters are important, because they hide internal implementation details.

# Import and Export
## Import
In the past, the function require() would be used to import the functions and code in external files and modules. 
While handy, this presents a problem: some files and modules are rather large, and you may only need certain code from those external resources.

ES6 gives us a very handy tool known as import. With it, we can choose which parts of a module or file to load into a given file, saving time and memory.

Consider the following example. Imagine that math_array_functions has about 20 functions, but I only need one, countItems, in my current file. 
The old require() approach would force me to bring in all 20 functions. With this new import syntax, I can bring in just the desired function, like so:
```javascript
import { countItems } from "math_array_functions"
```

A description of the above code:
```javascript
import { function } from "file_path_goes_here" // We can also import variables the same way!
```

There are a few ways to write an import statement, but the above is a very common use-case.

Note: the whitespace surrounding the function inside the curly braces is a best practice - it makes it easier to read the import statement.

### Import Everything
Suppose you have a file that you wish to import all of its contents into the current file. This can be done with the import * syntax.

Here's an example where the contents of a file named "math_functions" are imported into a file in the same directory:
```javascript
import * as myMathModule from "math_functions"
 myMathModule.add(2,3);
myMathModule.subtract(5,3);
```
And breaking down that code:
			import * as object_with_name_of_your_choice from "file_path_goes_here"
    			object_with_name_of_your_choice.imported_function

You may use any name following the import * as portion of the statement. In order to utilize this method, it requires an object that receives the imported values. 
From here, you will use the dot notation to call your imported values.

## Export
In the previous challenge, you learned about import and how it can be leveraged to import small amounts of code from large files. 
In order for this to work, though, we must utilize one of the statements that goes with import, known as export. 
When we want some code - a function, or a variable - to be usable in another file, we must export it in order to import it into another file. 
Like import, export is a non-browser feature.

The following is what we refer to as a named export. 
With this, we can import any code we export into another file with the import syntax you learned in the last lesson. Here's an example:
```javascript
const capitalizeString = (string) => {
      return string.charAt(0).toUpperCase() + string.slice(1);
}
export { capitalizeString } //How to export functions.
export const foo = "bar"; //How to export variables.
```
Alternatively, if you would like to compact all your export statements into one line, you can take this approach:
```javascript
const capitalizeString = (string) => {
      return string.charAt(0).toUpperCase() + string.slice(1);
}
const foo = "bar";
export { capitalizeString, bar }
```
Either approach is perfectly acceptable.

### Create an Export Fallback with export default
In the export lesson, you learned about the syntax referred to as a named export. 
This allowed you to make multiple functions and variables available for use in other files.

There is another export syntax you need to know, known as export default. Usually you will use this syntax if only one value is being exported from a file. 

It is also used to create a fallback value for a file or module. Here is a quick example of export default:
```javascript
export default const add = (x,y) => {
      return x + y;
}
```
There is a one major feature of export default you must never forget - since it is used to declare a fallback value for a module or file, you can only have one value be a default export in each module or file.

#### Import a Default Export
It is important to note that, to import a default export, you need to use a different import syntax.
In the following example, we have a function, add, that is the default export of a file, "math_functions". Here is how to import it:
```javascript
import add from "math_functions";
add(5,4); //Will return 9
```
The syntax differs in one key place - the imported value, add, is not surrounded by curly braces, {}. 
Unlike exported values, the primary method of importing a default export is to simply write the value's name after import.
